# Common Dockerfile for Hugo Websites

This Dockerfile uses multi-stage build. See [Docker documentation](https://docs.docker.com/develop/develop-images/multistage-build/) for more information about multi-stage builds. It has 2 stages: the first one builds the website with npm and Hugo, the second one builds the actual website container image by copying the static content generated by Hugo during the first stage into the current image. 

### First stage: Hugo generation
The first stage looks like this

```dockerfile
ARG BUILDER_IMAGE_TAG=latest
ARG NGINX_IMAGE_TAG=stable-alpine-for-hugo

FROM eclipsefdn/hugo-node:${BUILDER_IMAGE_TAG} AS builder

WORKDIR /workdir
COPY . /workdir/

RUN npm --unsafe-perm ci \
    && hugo --gc --minify
```

It’s based on `eclipsefdn/hugo-node` and is aliased *builder*, a name that we will reuse in the later stage. It has everything installed already (Node + Hugo). The included versions of Node and Hugo can be found in the [source Dockefiles](https://github.com/EclipseFdn/dockerfiles/tree/master/hugo-node). 

By default, the *latest* tag is used, but if another versions combination of Hugo and Node is required, the docker build command just needs to pass a different value for `BUILDER_IMAGE_TAG`, e.g., `--build-arg BUILDER_IMAGE_TAG=h0.62.2-n10.15.0`. Again, the list of available version is in the [dockerfiles github repository](https://github.com/EclipseFdn/dockerfiles/blob/master/build.sh).

The output of the Hugo generation will be available from the folder `/workdir/public` (i.e., current working directory + `/public`, the default output folder for Hugo generation).

### Second stage: website container image
The second stage looks like this

```Dockerfile
FROM eclipsefdn/nginx:${NGINX_IMAGE_TAG}
 
COPY --from=builder /workdir/public/ /usr/share/nginx/html/
```

It’s very simple. It’s based on `eclipsefdn/nginx` (defined in the [EclipseFdn/dockerfiles Github repository](https://github.com/EclipseFdn/dockerfiles/tree/master/nginx)). For now, don’t bother about the tag `${NGINX_IMAGE_TAG}`, we will talk about it in the next section.

The only thing done in this Dockerfile stage is to copy the files from the `/workdir/public` folder from the builder stage to the folder `/usr/share/nginx/html/` (aka the Nginx default document root) in the current stage.
Assembling everything together
The full Dockerfile is a bit more than just the concatenation of the two stage above as you can see below:

```Dockerfile
ARG BUILDER_IMAGE_TAG=latest
ARG NGINX_IMAGE_TAG=stable-alpine-for-hugo

FROM eclipsefdn/hugo-node:${BUILDER_IMAGE_TAG} AS builder
 
# <content from builder stage>
 
FROM eclipsefdn/nginx:${NGINX_IMAGE_TAG}
 
COPY --from=builder /workdir/public/ /usr/share/nginx/html/
```

We add a new build argument named `NGINX_IMAGE_TAG` at the top of the file. It will be used to select the parent Nginx image we want for the website image. As you already noticed in the  [EclipseFdn/dockerfiles Github repository](https://github.com/EclipseFdn/dockerfiles/tree/master/nginx), there are 2 tags:
* [stable-alpine](https://github.com/EclipseFdn/dockerfiles/blob/master/nginx/stable-alpine/Dockerfile)
* [stable-alpine-for-staging](https://github.com/EclipseFdn/dockerfiles/blob/master/nginx/stable-alpine-for-staging/Dockerfile)

Both images are based on the official Nginx images `nginx:stable-alpine` and both do the following changes in the official image:
* Listen on port 8080 instead of 80
* Create a `uid_entrypoint` script for compatibility with OKD security policy (see [OKD documentation](https://docs.openshift.com/container-platform/3.11/creating_images/guidelines.html#use-uid) for more information)
Set group ownership and write permission to the group root on `/usr/share/nginx/html` and `/var/cache/nginx` (again for OKD compatibility)
Deactivate the addition of port in redirection (see [port_in_redirect documentation](http://nginx.org/en/docs/http/ngx_http_core_module.html#port_in_redirect))

For staging site, we want to have basic auth with a dummy set of credentials to avoid search engines indexation. The default [stable-alpine](https://github.com/EclipseFdn/dockerfiles/blob/master/nginx/stable-alpine/Dockerfile) does not have basic auth and is aimed to be the parent image of production images while the [stable-alpine-for-staging](https://github.com/EclipseFdn/dockerfiles/blob/master/nginx/stable-alpine-for-staging/Dockerfile) has.

The [stable-alpine-for-staging](https://github.com/EclipseFdn/dockerfiles/blob/master/nginx/stable-alpine-for-staging/Dockerfile) use a multi-stage build: first it generates a .htpasswd file via the htpasswd command line tool. Then, in a second stage, this file is added to the final image. Finally, Nginx is configured to activate the auth_basic module for the / location and use the file as the source of credentials.

We’re now able to generate an image of our website that will be protected with basic authentication and dummy credentials by adding an argument to the docker build command:

```bash
$ docker build \
--build-arg NGINX_IMAGE_TAG=”stable-alpine-for-staging”
... 
```

Without this argument, the default value stable-alpine is used, and a normal production website image (without basic authentication) is generated.
